<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Shashank — Case Studies | Arohanagara</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700;800&display=swap" rel="stylesheet">

<style>
  :root{
    --bg:#020617;
    --surface:#020617;
    --card:#020617;
    --muted:#9ca3af;
    --accent1:#38bdf8;
    --accent2:#a855f7;
    --accent3:#22c55e;
    --border-soft:#1f2937;
    --shadow-soft:0 18px 45px rgba(15,23,42,0.75);
    --maxw:1060px;
  }
  *{box-sizing:border-box;margin:0;padding:0}
  html,body{height:100%}
  body{
    font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    background:
      radial-gradient(circle at 0% 0%, #0ea5e9 0, transparent 55%),
      radial-gradient(circle at 100% 0%, #a855f7 0, transparent 55%),
      radial-gradient(circle at 50% 100%, #22c55e 0, transparent 55%),
      linear-gradient(180deg,#020617 0%,#020617 100%);
    color:#e5e7eb;
    padding:24px 12px 32px;
    line-height:1.7;
  }

  .wrap{
    max-width:var(--maxw);
    margin:0 auto;
    display:flex;
    flex-direction:column;
    gap:20px;
  }

  .hero{
    border-radius:24px;
    padding:18px 18px 16px;
    background:linear-gradient(135deg,rgba(15,23,42,0.96),rgba(15,23,42,0.96));
    border:1px solid rgba(148,163,184,0.4);
    box-shadow:var(--shadow-soft);
    display:flex;
    justify-content:space-between;
    gap:14px;
  }
  .hero-left{
    display:flex;
    gap:14px;
  }
  .logo{
    width:60px;height:60px;border-radius:18px;
    background:conic-gradient(from 210deg,var(--accent1),var(--accent2),var(--accent3),var(--accent1));
    display:flex;align-items:center;justify-content:center;
    color:#020617;font-weight:900;font-size:22px;
    box-shadow:0 0 0 3px rgba(15,23,42,0.9);
  }
  .hero-tag{
    color:#38bdf8;font-size:0.8rem;text-transform:uppercase;letter-spacing:0.12em;margin-bottom:4px;
  }
  h1{
    font-size:1.35rem;
    margin-bottom:4px;
    color:#f9fafb;
  }
  .hero-sub{
    color:var(--muted);
    font-size:0.95rem;
  }
  .hero-right{
    text-align:right;
    font-size:0.86rem;
    color:var(--muted);
    display:flex;
    flex-direction:column;
    gap:4px;
    align-items:flex-end;
  }
  .hero-right code{color:#e5e7eb}
  .hero-links{
    display:flex;gap:8px;margin-top:4px;flex-wrap:wrap;justify-content:flex-end;
  }
  .hero-links a{
    font-size:0.78rem;
    padding:3px 8px;
    border-radius:999px;
    border:1px solid rgba(148,163,184,0.6);
    color:#e5e7eb;
    text-decoration:none;
    background:rgba(15,23,42,0.8);
  }

  .controls{
    display:flex;
    flex-wrap:wrap;
    gap:10px;
    align-items:center;
    justify-content:space-between;
    margin-top:2px;
  }
  .view-toggle{
    display:inline-flex;
    align-items:center;
    background:rgba(15,23,42,0.9);
    border-radius:999px;
    border:1px solid rgba(148,163,184,0.5);
    padding:3px;
  }
  .view-toggle button{
    border:none;
    background:transparent;
    color:var(--muted);
    font-size:0.78rem;
    padding:4px 10px;
    border-radius:999px;
    cursor:pointer;
  }
  .view-toggle button.active{
    background:rgba(15,23,42,1);
    color:#e5e7eb;
  }
  .legend{
    font-size:0.76rem;
    color:var(--muted);
    display:flex;
    flex-wrap:wrap;
    gap:10px;
  }
  .legend span{
    display:inline-flex;
    align-items:center;
    gap:4px;
  }
  .legend-dot{
    width:8px;height:8px;border-radius:999px;
    background:var(--accent1);
  }

  .main{
    display:flex;
    gap:18px;
    align-items:flex-start;
  }
  .left-col{
    flex:3;
    display:flex;
    flex-direction:column;
    gap:12px;
  }
  .right-col{
    flex:1.3;
    min-width:220px;
    max-width:260px;
  }

  .cards.grid{
    display:grid;
    grid-template-columns:repeat(auto-fit,minmax(260px,1fr));
    gap:16px;
  }
  .cards.list{
    display:flex;
    flex-direction:column;
    gap:10px;
  }

  .card{
    background:radial-gradient(circle at top left,rgba(56,189,248,0.08),transparent 55%),
               radial-gradient(circle at bottom right,rgba(168,85,247,0.1),transparent 55%),
               rgba(15,23,42,0.96);
    border-radius:18px;
    padding:14px 14px 12px;
    border:1px solid rgba(148,163,184,0.5);
    box-shadow:0 12px 32px rgba(15,23,42,0.7);
    position:relative;
    display:flex;
    flex-direction:column;
    gap:6px;
  }

  .card-tag{
    font-size:0.72rem;
    text-transform:uppercase;
    letter-spacing:0.16em;
    color:#38bdf8;
  }
  .card-title{
    font-size:0.98rem;
    font-weight:600;
    color:#f9fafb;
  }
  .card-kicker{
    font-size:0.78rem;
    color:var(--muted);
  }
  .card-body{
    font-size:0.82rem;
    color:var(--muted);
  }

  .ds-tags{
    display:flex;
    flex-wrap:wrap;
    gap:6px;
    margin-top:4px;
  }
  .ds-tag{
    font-size:0.72rem;
    padding:2px 7px;
    border-radius:999px;
    border:1px solid rgba(148,163,184,0.7);
    color:#e5e7eb;
    background:rgba(15,23,42,0.9);
  }

  .impl{
    margin-top:8px;
    display:flex;
    justify-content:flex-end;
  }

  .cta-btn{
    display:inline-flex;
    align-items:center;
    gap:6px;
    font-size:0.78rem;
    padding:5px 10px;
    border-radius:999px;
    border:1px solid rgba(148,163,184,0.7);
    background:rgba(15,23,42,0.9);
    color:#e5e7eb;
    cursor:pointer;
  }
  .cta-btn:hover{
    background:rgba(15,23,42,1);
  }
  .cta-icon{
    width:15px;height:15px;border-radius:999px;
    background:radial-gradient(circle at 30% 20%,#38bdf8,transparent 55%),
               radial-gradient(circle at 70% 70%,#a855f7,transparent 55%),
               rgba(15,23,42,1);
    border:1px solid rgba(148,163,184,0.9);
  }

  .desc-panel{
    background:radial-gradient(circle at 20% 0,rgba(56,189,248,0.24),transparent 55%),
               radial-gradient(circle at 80% 100%,rgba(34,197,94,0.24),transparent 55%),
               rgba(15,23,42,0.96);
    border-radius:18px;
    padding:14px;
    border:1px solid rgba(148,163,184,0.6);
    box-shadow:0 16px 40px rgba(15,23,42,0.85);
    font-size:0.84rem;
  }
  .desc-title{
    font-size:0.95rem;
    font-weight:600;
    margin-bottom:6px;
  }
  .desc-tag{
    font-size:0.76rem;
    color:#38bdf8;
    text-transform:uppercase;
    letter-spacing:0.16em;
    margin-bottom:4px;
  }
  .desc{
    color:var(--muted);
  }
  .ds-list{
    margin-top:10px;
    padding-top:6px;
    border-top:1px solid rgba(148,163,184,0.5);
  }
  .ds-list-title{
    font-size:0.78rem;
    color:#e5e7eb;
    margin-bottom:4px;
  }
  .ds-list ul{
    list-style:none;
    padding-left:0;
    font-size:0.8rem;
    color:var(--muted);
  }
  .ds-list li{
    margin-bottom:3px;
  }

  .side-panel{
    background:linear-gradient(145deg,rgba(15,23,42,0.96),rgba(15,23,42,0.96));
    border-radius:18px;
    border:1px solid rgba(148,163,184,0.55);
    padding:12px;
    box-shadow:0 16px 40px rgba(15,23,42,0.85);
    font-size:0.8rem;
    color:var(--muted);
    position:sticky;
    top:20px;
  }
  .side-title{
    font-size:0.9rem;
    font-weight:600;
    margin-bottom:6px;
    color:#f9fafb;
  }
  .side-section{
    margin-bottom:10px;
  }
  .side-section:last-child{margin-bottom:0}
  .side-section h4{
    font-size:0.78rem;
    text-transform:uppercase;
    letter-spacing:0.14em;
    color:#38bdf8;
    margin-bottom:4px;
  }
  .side-section ul{
    list-style:none;
    padding-left:0;
  }
  .side-section li{
    margin-bottom:2px;
  }
  .side-section code{
    font-size:0.78rem;
    color:#e5e7eb;
  }

  .badge{
    display:inline-flex;
    align-items:center;
    gap:6px;
    font-size:0.75rem;
    padding:4px 8px;
    border-radius:999px;
    border:1px solid rgba(148,163,184,0.7);
    color:#e5e7eb;
    background:rgba(15,23,42,0.9);
    margin-top:4px;
  }
  .badge-dot{
    width:7px;height:7px;border-radius:999px;
    background:radial-gradient(circle at 30% 30%,#22c55e,transparent 55%),
               rgba(15,23,42,1);
    border:1px solid rgba(34,197,94,0.9);
  }

  .footer-note{
    font-size:0.76rem;
    color:var(--muted);
    margin-top:8px;
  }

  @media (max-width:780px){
    .hero{flex-direction:column;align-items:flex-start;}
    .hero-right{align-items:flex-start;text-align:left;}
    .main{flex-direction:column;}
    .right-col{position:static;max-width:100%;width:100%;}
    .side-panel{position:static;}
  }
</style>
</head>
<body>
<div class="wrap">
  <header class="hero">
    <div class="hero-left">
      <div class="logo">S</div>
      <div>
        <div class="hero-tag">Arohanagara · Case Studies</div>
        <h1>Shashank – Smart Mobility & Urban Systems</h1>
        <p class="hero-sub">
          Ten graph, heap, and greedy–based scenarios for an emerging smart city:
          from ride-sharing dispatch and EV charging allocation to dynamic tolling, smart parking, and adaptive traffic lights.
        </p>
      </div>
    </div>
    <div class="hero-right">
      <div>Implementation language: de>C++17</code></div>
      <div>Dataset format: de>CSV</code> · Complexity notations: de>O( )</code>, de>Θ( )</code></div>
      <div class="hero-links">
        <a href="index.html">← Back to Index</a>
        <a href="https://github.com/atharva-in-bits/DAA-2025/tree/main/Shashank" target="_blank" rel="noopener">GitHub Folder</a>
      </div>
    </div>
  </header>

  <div class="controls">
    <div class="view-toggle" aria-label="Toggle between grid and list view">
      <button type="button" id="gridViewBtn" class="active">Grid View</button>
      <button type="button" id="listViewBtn">List View</button>
    </div>
    <div class="legend">
      <span><span class="legend-dot"></span> Real-world scenario mapped to core DSA</span>
      <span>Code + CSV for each case in Shashank folder</span>
    </div>
  </div>

  <main class="main">
    <section class="left-col">
      <div id="cardsContainer" class="cards grid">
        <!-- Cards injected by JS -->
      </div>
      <p class="footer-note">
        Each case here links directly to Shashank’s C++ implementation in the de>Shashank/</code> folder and a matching CSV dataset
        generated for experimentation, complexity analysis, and “what-if” modifications.
      </p>
    </section>

    <aside class="right-col">
      <div class="side-panel">
        <div class="side-section">
          <div class="side-title">Design Focus</div>
          <p>
            Shashank’s cases emphasize networked mobility, smart infrastructure, and real-time decisions:
            shortest paths, dynamic dispatch, traffic-aware tolling, and energy-aware control.
          </p>
          <div class="badge">
            <span class="badge-dot"></span>
            <span>Built for DAA 2025 – BITS Pilani</span>
          </div>
        </div>

        <div class="side-section">
          <h4>Core Techniques</h4>
          <ul>
            <li>de>Dijkstra</code> for route choice & delays</li>
            <li>de>Heaps</code> for priority dispatch & events</li>
            <li>de>Graphs</code> for networks (roads, pipes, signals)</li>
            <li>de>Greedy</code> for tolling & resource allocation</li>
          </ul>
        </div>

        <div class="side-section">
          <h4>How to Read a Case</h4>
          <ul>
            <li>1. Skim the narrative & DS list</li>
            <li>2. Open the C++ file via “View C++ Code”</li>
            <li>3. Inspect the CSV via “View Dataset”</li>
            <li>4. Trace how one trip/request moves through the system</li>
          </ul>
        </div>
      </div>
    </aside>
  </main>
</div>

<script>
  // helper
  function el(tag, cls){
    const e=document.createElement(tag);
    if(cls) e.className=cls;
    return e;
  }

  const cases = [
    {
      id:1,
      tag:'Ride-Sharing',
      title:'Ride-Sharing & Dynamic Dispatch System',
      kicker:'Case 1 · Ride-Sharing',
      summary:`An app-based ride-sharing platform in Arohanagara must match riders to drivers in real time, across different localities and traffic conditions.`,
      implText:'C++ source for all algorithms',
      implLink:'Shashank/Case1.cpp',
      // dataset link added
      dataLink:'Shashank/shashank-case1-ride-sharing(case-1).csv',
      tags:['BFS','Dijkstra','Heaps','Queues','Hashing','Structures'],
      desc:`The city’s road network is modelled as a weighted graph where intersections are nodes and road segments are edges with travel times that change by time-of-day. Incoming ride requests are queued; for each request, nearby candidate drivers are looked up in hashed buckets by locality and pushed into a min-heap keyed by ETA and detour penalty. A combination of breadth-first search for local reachability and Dijkstra’s algorithm for accurate shortest paths lets the platform quickly estimate travel times to each rider, while the heap ensures that the best driver–rider pair is always extracted in logarithmic time. The design balances fast local matching with globally reasonable detours and travel times.`,
      ds:[
        'Graph: adjacency list for road network, with time-dependent weights.',
        'Hash tables: map zones/localities to active drivers.',
        'Min-heap: riders waiting, keyed by driver ETA and detour penalty.',
        'Queues: streaming ride requests and dispatch events.'
      ]
    },
    {
      id:2,
      tag:'EV Charging',
      title:'EV Charging Slot Allocation & Dynamic Pricing',
      kicker:'Case 2 · EV Charging',
      summary:`A network of EV charging stations must allocate plugs to incoming vehicles, decide charging start times, and vary tariffs based on demand.`,
      implText:'C++ source for all algorithms',
      implLink:'Shashank/Case2.cpp',
      dataLink:'Shashank/shashank-case2-ev-charging(case-2).csv',
      tags:['Priority Queues','Greedy','Heaps','Hashing'],
      desc:`Each EV charging station has a fixed number of fast and normal charging slots, with vehicles arriving according to a time-stamped request stream. Requests are stored in a hash table keyed by station and connector type, then placed in a priority queue where the key combines urgency (battery level), requested departure time, and expected charging duration. A greedy allocator repeatedly extracts the highest-priority request and assigns it to the earliest available slot that meets its constraints; when no slot is immediately available, it computes a deferred start time and updates the heap. Tariffs vary based on local demand, computed from recent heap sizes and utilization history. The overall structure keeps lookups and updates efficient while ensuring highly utilized but fair slot allocation.`,
      ds:[
        'Hash map: stations × connector types → local request pools.',
        'Min-heap or max-heap: prioritizes vehicles by urgency & constraints.',
        'Greedy: repeatedly allocate the best feasible request to the earliest free slot.',
        'Arrays: track connector availability and station utilization.'
      ]
    },
    {
      id:3,
      tag:'Warehouse Routing',
      title:'Warehouse Order Picking & Route Optimization',
      kicker:'Case 3 · Warehouse Routing',
      summary:`A central warehouse must schedule pickers and plan efficient routes for fulfilling orders spread across multiple storage aisles.`,
      implText:'C++ source for all algorithms',
      implLink:'Shashank/Case3.cpp',
      dataLink:'Shashank/shashank-case3-warehouse-routing(case-3).csv',
      tags:['Graphs','Shortest Path','Greedy'],
      desc:`The warehouse floor is represented as a grid or graph where nodes are aisle intersections and edges are walking paths with traversal times. Orders arrive as sets of item locations; for each picker, the system clusters nearby orders and sequences locations using a greedy nearest-neighbour heuristic, approximating a travelling-salesperson route. Edge weights reflect congestion and one-way constraints within aisles. To avoid global recomputation, precomputed shortest-path tables or repeated Dijkstra runs over the warehouse layout are reused across orders. The overall goal is to minimize walking distance and average completion time without solving the full NP-hard routing problem exactly.`,
      ds:[
        'Graph: nodes for intersections, edges for walkable paths with weights.',
        'Arrays: store item locations and picker assignments.',
        'Greedy heuristics: nearest-neighbour ordering of locations per route.',
        'Optional: precomputed all-pairs shortest paths for a static layout.'
      ]
    },
    {
      id:4,
      tag:'Recycling',
      title:'Recyclable Waste Collection & Routing',
      kicker:'Case 4 · Recycling & Solid Waste',
      summary:`Municipal trucks in Arohanagara must collect different waste streams (dry, wet, plastic, e-waste) from households and bulk generators.`,
      implText:'C++ source for all algorithms',
      implLink:'Shashank/Case4.cpp',
      dataLink:'Shashank/shashank-case4-recycling-routing(case-4).csv',
      tags:['Graphs','Greedy','Heaps'],
      desc:`Residential neighbourhoods and collection points are modelled as nodes in a graph, with edges encoding road segments and expected travel times. Requests for pickup (by waste type and volume) are queued and grouped into routes using greedy clustering around depots and transfer stations. A priority queue ranks potential next stops for each truck by a combined score of detour cost, remaining capacity, and missed-service penalty. This allows the system to construct near-optimal routes incrementally, without requiring full vehicle-routing optimization. Graph traversal and heap operations keep the per-decision cost manageable even as the number of households grows.`,
      ds:[
        'Graph: road network between households, depots, and transfer stations.',
        'Priority queue: candidate stops for each truck, keyed by detour and capacity impact.',
        'Greedy routing: sequentially extend each truck’s route by the best next stop.',
        'Queues: pending collection requests by waste category.'
      ]
    },
    {
      id:5,
      tag:'Corridor Tolling',
      title:'Dynamic Corridor Tolling & Congestion Management',
      kicker:'Case 5 · Dynamic Tolling',
      summary:`A set of important city corridors in Arohanagara must be priced dynamically to manage congestion while maintaining throughput.`,
      implText:'C++ source for all algorithms',
      implLink:'Shashank/Case5.cpp',
      dataLink:'Shashank/shashank-case5-corridor-toll(case-5).csv',
      tags:['Greedy','Heaps','Sliding Windows'],
      desc:`Each corridor is modelled as a sequence of segments, and the system tracks real-time vehicle counts, speeds, and travel times. A sliding-window data structure maintains recent traffic metrics; toll rates are adjusted greedily according to congestion levels compared to target thresholds. A min-heap or max-heap is used to quickly identify the most congested corridors for intervention, while hashing keeps lookups by corridor ID efficient. The goal is to set tolls that push demand away from heavily loaded routes while preserving reasonable journey times for essential traffic.`,
      ds:[
        'Sliding window arrays or queues for recent flow and speed per corridor.',
        'Heaps to rank corridors by deviation from target congestion.',
        'Greedy adjustments of tolls in small increments per time step.',
        'Hash maps for fast access to corridor state by ID.'
      ]
    },
    {
      id:6,
      tag:'Predictive Maintenance',
      title:'Fleet & Equipment Predictive Maintenance',
      kicker:'Case 6 · Predictive Maintenance',
      summary:`Vehicles and equipment across the city generate sensor readings that must be used to anticipate failures and schedule maintenance.`,
      implText:'C++ source for all algorithms',
      implLink:'Shashank/Case6.cpp',
      dataLink:'Shashank/shashank-case6-predictive-maintenance(case-6).csv',
      tags:['Heaps','Hashing','Greedy'],
      desc:`Each asset in the fleet or equipment inventory is tracked in a hash table keyed by ID, storing its latest sensor values, usage hours, and maintenance history. A risk score is computed from temperature, vibration, and time since last service; assets with the highest scores are placed into a max-heap, from which maintenance slots are greedily assigned given limited workshop capacity. The system aims to minimize unplanned downtime and repair costs by scheduling just-in-time service. Hash tables ensure constant-time access to asset records, while heap operations keep the global prioritisation efficient.`,
      ds:[
        'Hash tables mapping asset IDs to health and history records.',
        'Max-heap of assets, keyed by risk score.',
        'Greedy scheduling of maintenance windows given limited capacity.',
        'Arrays/queues for booked and completed maintenance tasks.'
      ]
    },
    {
      id:7,
      tag:'Smart Parking',
      title:'Smart Parking Allocation & Pricing',
      kicker:'Case 7 · Smart Parking',
      summary:`Parking lots in busy neighbourhoods must allocate spots to incoming vehicles, handle reservations, and adjust prices dynamically.`,
      implText:'C++ source for all algorithms',
      implLink:'Shashank/Case7.cpp',
      dataLink:'Shashank/shashank-case7-smart-parking(case-7).csv',
      tags:['Heaps','Hashing','Greedy'],
      desc:`Each parking lot exposes a stream of entry requests, exit events, and advance reservations. Spots are stored in a hash map keyed by lot and level, with a min-heap for each lot representing the soonest-free spots. When a vehicle arrives, the allocator consults the heap and reservation constraints to choose a spot that minimizes walking distance and respects time windows. Pricing is adjusted based on occupancy using simple greedy rules; lots nearing full capacity have their rates increased, and underused ones get discounts. This structure keeps both allocation and pricing responsive to real-time conditions.`,
      ds:[
        'Hash tables mapping (lot, level) to spots and occupancy.',
        'Min-heaps keyed by “available from” time for each spot.',
        'Greedy allocation of spots to requests, respecting reservations.',
        'Simple dynamic pricing rules based on occupancy thresholds.'
      ]
    },
    {
      id:8,
      tag:'Smart Streetlights',
      title:'Smart Streetlight Dimming & Energy Optimization',
      kicker:'Case 8 · Smart Streetlights',
      summary:`Streetlights in Arohanagara adjust brightness based on ambient light, traffic, and time of night to save energy while ensuring safety.`,
      implText:'C++ source for all algorithms',
      implLink:'Shashank/Case8.cpp',
      dataLink:'Shashank/shashank-case8-smart-streetlights(case-8).csv',
      tags:['Greedy','Sliding Windows'],
      desc:`Each streetlight (or small cluster) reports ambient brightness, motion detection, and energy consumption data. A sliding window tracks recent readings; the controller greedily sets the dimming level to the lowest safe value considering current traffic and time-of-night. Sections of a road can be coordinated using simple local heuristics rather than solving a global optimization, relying on the sliding-window history and thresholds tuned for different road classes. This arrangement yields substantial energy savings with acceptable computational overhead.`,
      ds:[
        'Sliding window histories of brightness and traffic per light or segment.',
        'Greedy dimming rules that trade off safety vs. energy savings.',
        'Simple adjacency structures to coordinate neighbouring lights.',
        'Hash maps linking pole IDs to configuration and state.'
      ]
    },
    {
      id:9,
      tag:'Water Network',
      title:'Urban Water Distribution & Pressure Management',
      kicker:'Case 9 · Water Pipelines',
      summary:`The city’s water network must deliver adequate pressure across zones while minimizing pumping costs and leakage risk.`,
      implText:'C++ source for all algorithms',
      implLink:'Shashank/Case9.cpp',
      dataLink:'Shashank/shashank-case9-water-pipeline(case-9).csv',
      tags:['Graphs','Shortest Path','Greedy'],
      desc:`Pipes and junctions form a graph; sources such as reservoirs and pumping stations inject water at controlled pressures. The system monitors flows and pressures at key nodes and adjusts valve settings or pump outputs to keep pressures within acceptable bounds, using graph traversal to propagate constraints. When a leak or blockage is suspected in a segment, alternate paths are explored via shortest-path algorithms that respect capacity limits. Greedy control rules balance pressure and energy cost while avoiding excessive reconfiguration.`,
      ds:[
        'Graph of pipes and junctions with capacities and nominal pressures.',
        'Arrays for current flows, node pressures, and valve states.',
        'Shortest-path routines to find alternate supply paths.',
        'Greedy adjustments of pump outputs and valve positions.'
      ]
    },
    {
      id:10,
      tag:'Traffic Signals',
      title:'Adaptive Traffic Signal Timing',
      kicker:'Case 10 · Traffic Signals',
      summary:`Major intersections in Arohanagara adjust their signal timings based on observed queue lengths and time-of-day patterns.`,
      implText:'C++ source for all algorithms',
      implLink:'Shashank/Case10.cpp',
      dataLink:'Shashank/shashank-case10-traffic-signals(case-10).csv',
      tags:['Heaps','Queues','Graphs'],
      desc:`Each intersection aggregates queue-length and wait-time measurements per approach and phase. A cyclic schedule is maintained, with a priority queue of candidate adjustments based on observed delays and fairness constraints. When an approach’s queue grows too large, the controller proposes a temporary increase in green time drawn from less-loaded phases, subject to minimum and maximum bounds. Graphs describe coordination constraints between nearby intersections along a corridor, so that spillbacks and green-wave patterns can be handled. Queue and heap operations keep controller decisions timely even in busy networks.`,
      ds:[
        'Queues: per-approach vehicle queues and recent delay samples.',
        'Priority queue: candidate green-time adjustments ranked by impact.',
        'Graph: adjacency of intersections for corridor coordination.',
        'Arrays: current cycle plans and phase bounds.'
      ]
    }
  ];

  const cardsContainer = document.getElementById('cardsContainer');
  const gridBtn = document.getElementById('gridViewBtn');
  const listBtn = document.getElementById('listViewBtn');

  function esc(s){return String(s);}

  function renderGrid(list){
    cardsContainer.innerHTML='';
    cardsContainer.className='cards grid';

    list.forEach(c=>{
      const card=el('article','card');

      const tag=el('div','card-tag');
      tag.textContent=c.tag;
      card.appendChild(tag);

      const title=el('div','card-title');
      title.textContent=c.title;
      card.appendChild(title);

      const kicker=el('div','card-kicker');
      kicker.textContent=c.kicker;
      card.appendChild(kicker);

      const body=el('div','card-body');
      body.textContent=c.summary;
      card.appendChild(body);

      const dsTags=el('div','ds-tags');
      c.tags.forEach(t=>{
        const span=el('span','ds-tag');
        span.textContent=t;
        dsTags.appendChild(span);
      });
      card.appendChild(dsTags);

      const impl=el('div','impl');

      // new wrapper to shift left and hold two buttons
      const btnWrap = el('div');
      btnWrap.style.display = 'flex';
      btnWrap.style.gap = '8px';
      btnWrap.style.transform = 'translateX(-6px)';

      // View C++ Code button
      const codeBtn = el('button','cta-btn');
      codeBtn.setAttribute('data-link', esc(c.implLink));
      codeBtn.setAttribute('data-title', esc(c.title));
      codeBtn.innerHTML = `<span class="cta-icon" aria-hidden="true"></span><span>View C++ Code</span>`;
      btnWrap.appendChild(codeBtn);

      // View Dataset button
      const dataBtn = el('button','cta-btn');
      dataBtn.setAttribute('data-datalink', esc(c.dataLink));
      dataBtn.setAttribute('data-title', esc(c.title));
      dataBtn.innerHTML = `<span class="cta-icon" aria-hidden="true"></span><span>View Dataset</span>`;
      btnWrap.appendChild(dataBtn);

      impl.appendChild(btnWrap);
      card.appendChild(impl);

      cardsContainer.appendChild(card);
    });
  }

  function renderList(list){
    cardsContainer.innerHTML='';
    cardsContainer.className='cards list';

    list.forEach(c=>{
      const card=el('article','card');

      const header=el('div');
      header.style.display='flex';
      header.style.justifyContent='space-between';
      header.style.alignItems='baseline';
      header.style.gap='10px';

      const left=el('div');
      const tag=el('div','card-tag');
      tag.textContent=c.tag;
      left.appendChild(tag);

      const title=el('div','card-title');
      title.textContent=c.title;
      left.appendChild(title);

      const kicker=el('div','card-kicker');
      kicker.textContent=c.kicker;
      left.appendChild(kicker);

      header.appendChild(left);

      const right=el('div');

      // same two-button layout for list
      const btnWrap = el('div');
      btnWrap.style.display = 'flex';
      btnWrap.style.gap = '8px';
      btnWrap.style.transform = 'translateX(-6px)';

      const codeBtn = el('button','cta-btn');
      codeBtn.setAttribute('data-link', esc(c.implLink));
      codeBtn.setAttribute('data-title', esc(c.title));
      codeBtn.innerHTML = `<span class="cta-icon" aria-hidden="true"></span><span>View C++ Code</span>`;
      btnWrap.appendChild(codeBtn);

      const dataBtn = el('button','cta-btn');
      dataBtn.setAttribute('data-datalink', esc(c.dataLink));
      dataBtn.setAttribute('data-title', esc(c.title));
      dataBtn.innerHTML = `<span class="cta-icon" aria-hidden="true"></span><span>View Dataset</span>`;
      btnWrap.appendChild(dataBtn);

      right.appendChild(btnWrap);
      header.appendChild(right);

      card.appendChild(header);

      const body=el('div','card-body');
      body.textContent=c.summary;
      card.appendChild(body);

      const dsTags=el('div','ds-tags');
      c.tags.forEach(t=>{
        const span=el('span','ds-tag');
        span.textContent=t;
        dsTags.appendChild(span);
      });
      card.appendChild(dsTags);

      cardsContainer.appendChild(card);
    });
  }

  function openLink(href){
    if(!href) return;
    window.open(href,'_blank','noopener');
  }

  function onCardClick(e){
    const btn=e.target.closest('button.cta-btn');
    if(!btn) return;

    const codeLink = btn.getAttribute('data-link');
    const dataLink = btn.getAttribute('data-datalink');
    const title = btn.getAttribute('data-title') || 'Shashank Case';

    // decide which link to open
    if (dataLink) {
      openLink(dataLink);
    } else if (codeLink) {
      openLink(codeLink);
    }
  }

  cardsContainer.addEventListener('click', onCardClick);

  gridBtn.addEventListener('click',()=>{
    gridBtn.classList.add('active');
    listBtn.classList.remove('active');
    renderGrid(cases);
  });
  listBtn.addEventListener('click',()=>{
    listBtn.classList.add('active');
    gridBtn.classList.remove('active');
    renderList(cases);
  });

  renderGrid(cases);
</script>
</body>
</html>
